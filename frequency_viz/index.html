<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Frequency Matrix Isolines</title>

    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="../dist/marchingsquares-isolines.js"></script>
    <style>
        .isocontours svg {
            position: absolute;
            top: 0;
            left: 0;
        }

        .frequency svg {
            position: absolute;
            top: 0;
            right: 0;
        }
    </style>
    <!--start with svg
        grab from dom everytime drawlines is called
    -->

</head>
<body>

<div id="isocontours" class = "isocontours"></div>
<div id="frequency" class = "frequency"></div>

<script>
    var colorRanges =
        [[d3.rgb(191, 211, 205), d3.rgb(181, 222, 208), d3.rgb(112, 211, 179), d3.rgb(89, 213, 172)],
         [d3.rgb(255, 170, 170), d3.rgb(212, 106, 106), d3.rgb(128, 21, 21), d3.rgb(85, 0, 0)],
         [d3.rgb(255, 230, 21), d3.rgb(227, 203, 0), d3.rgb(120, 107, 0), d3.rgb(44, 39, 0)]];


/*
    var input = [
[0, 0, 0],
[0, 0, 0],
[0, 0, 0.8],
[0, 0, 0.4],
[0.4, 0, 0.6],
[0, 0.7, 0],
[0.7, 0, 0],
[0.7, 0, 0],
[0, 0.9, 0],
[0.7, 0, 0],
[0.7, 0, 0],
[0, 0, 0],];

*/

    /*var input = [
        [0.3, 0.2, 0.1],
        [0.3, 0.2, 0.3],
        [0.3, 0.2, 0.3],
        [0.3, 0.4, 0.4],
        [0.3, 0.5, 0.3],
        [0.3, 0.7, 0.1],
        [0.3, 0.7, 0.2],
        [0.3, 0.6, 0.1],
        [0.3, 0.4, 0.3],
        [0.3, 0.2, 0.2],
        [0.3, 0.2, 0.1],
        [0.3, 0.2, 0.4],
        [0.3, 0.2, 0.6],
        [0.3, 0.2, 0.7],
        [0.3, 0.2, 0.5],
        [0.3, 0.2, 0.3],
        [0.3, 0.2, 0.3],
        [0.3, 0.2, 0.3],
        [0.4, 0.2, 0.3],
        [0.5, 0.2, 0.3],
        [0.7, 0.2, 0.1],
        [0.7, 0.2, 0.3],
        [0.5, 0.2, 0.3],
        [0.4, 0.5, 0.4],
        [0.3, 0.7, 0.3],
        [0.2, 0.7, 0.4],
        [0.5, 0.3, 0.3],
        [0.7, 0.3, 0.1],
        [0.5, 0.6, 0.3],
        [0.7, 0.4, 0.2],
        [0.3, 0.3, 0.1],
        [0.3, 0.6, 0.3],
        [0.3, 0.7, 0.3],
        [0.3, 0.6, 0.3],
        [0.3, 0.4, 0.3],
        [0.7, 0.3, 0.3],
        [0.3, 0.2, 0.3],
        [0.3, 0.2, 0.3],
        [0.3, 0.2, 0.3],
        [0.3, 0.2, 0.3],
    ];*/

    // grid = 4 x 3 
    // n x m 

    var intervals = [0,0.7];
//TODO: make sure rows dont sum up to > 1
    var input = [
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0.7],
[0, 0, 0.7],
[0, 0, 0.7],
[0, 0, 0],
[0, 0, 0],
[0, 0.7, 0],
[0, 0.7, 0],
[0, 0.7, 0],
[0, 0, 0],
[0, 0, 0.7],
[0, 0, 0.7],
[0, 0, 0],
[0, 0, 0],
[0, 0.7, 0],
[0, 0, 0],
[0, 0.7, 0],
[0, 0.7, 0],
[0, 0.7, 0],
[0, 0.7, 0],
[0, 0, 0],
[0, 0, 0.6],
[0, 0.7, 0],
[0.7, 0, 0],
[0.7, 0, 0],
[0.7, 0, 0],
[0, 0, 0],
[0, 0.7, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0.7, 0],
[0.7, 0, 0],
[0.7, 0, 0],
[0.7, 0, 0],
[0, 0, 0],
[0, 0.7, 0],
[0, 0, 0.4],
[0, 0, 0],
[0, 0.7, 0],
[0, 0.7, 0],
[0, 0.7, 0],
[0, 0.7, 0],
[0, 0.7, 0],
[0, 0.7, 0],
[0, 0, 0.5],
[0, 0, 0],
[0, 0, 0.5],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
    ];

    //input represents u

    var f = [];
    for(var row = 0; row < input.length;row++) {
        f[row] = new Array(3);
    }

    for(var row = 0; row < input.length;row++) {
        for (var col = 0; col < input[0].length;col++) {
            if (col == 0) {
                num = input[row][0] + input[row][1] + input[row][2];
                f[row][col] = num;
            } else {
                f[row][col] = input[row][col];    
            }
        }
    }


    var m = 8;
    // 64 lines 
    // 8 x 8

    var size = input.length;
    var temp = []
    /*var data = [
        [0.3, 0.3, 0.3],
        [0.3, 0.7, 0.3],
        [0.3, 0.7, 0.3],
        [0.3, 0.3, 0.3],
    ];*/

for(var canvas=0; canvas < 2; canvas++) {
    var div = "";
    var matrix = input;
    if(canvas==0){
        matrix = input;
        div = "#isocontours";
    } else {
        matrix = f;
        div = "#frequency";
    }

    for(var index = 0; index < input[0].length; index++) {


        var grid = [];
        temp = [];

        for(var i = 0; i < size; i++) {
            if(i!=0 && i%m == 0) {
                grid.push(temp);
                temp = [];
            }
            temp.push(matrix[i][index]);
        }
        grid.push(temp);
debugger


        var x = d3.range(0, grid[0].length);
        var y = d3.range(0, grid.length);

        var isoLines = [];
        MarchingSquaresJS
          .isoLines(grid,
                    intervals,
                    {
                        polygons: false,
                        linearRing: false
                    }
          )
          .forEach(function(isolines, i) {
            isoLines.push({
              "coords": isolines,
              "level": i + 1,
              "val": intervals[i]});
          });

          // 

        drawLines(div, isoLines, intervals, x, y);



        // helper function
        function drawLines(divId, lines, intervals, xs, ys) {

            var marginBottomLabel = 0;

            var width = 500;
            var height = width * (ys.length / xs.length);

            var xScale = d3.scale.linear()
                .range([0, width])
                .domain([Math.min.apply(null, xs), Math.max.apply(null, xs)]);

            var yScale = d3.scale.linear()
                .range([0, height])
                .domain([Math.min.apply(null, ys), Math.max.apply(null, ys)]);

            var colours = d3.scale.linear().domain([intervals[0], intervals[intervals.length - 1]])
                .range(colorRanges[index]);

            var svg = d3.select(divId)
                .append("svg")
                .attr("width", width)
                .attr("height", height + marginBottomLabel);

            svg.selectAll("path")
                .data(lines)
                .enter().append("path")
                .style("fill", "none")
                .style("stroke", function (d) {
                    return colours(d.val);
                })
                .style("stroke-width", 1)
                .style('opacity', 1.0)
                .attr("d", function (d) {
                    var p = "";
                    d.coords.forEach(function (aa) {
                        p += (d3.svg.line()
                            .x(function (dat) {
                                return xScale(dat[0]);
                            })
                            .y(function (dat) {
                                return yScale(dat[1]);
                            })
                            .interpolate("linear")
                        )(aa) + "";
                    });
                    return p;
                })
                .on('mouseover', function () {
                    d3.select(this)
                    .style('stroke', d3.rgb(204, 185, 116))
                    .style("stroke-width", 3);
                })
                .on('mouseout', function () {
                    d3.select(this)
                    .style('stroke', function (d1) {
                        return colours(d1.val);
                    })
                    .style("stroke-width", 1);
                });
        }

    }
}
    
</script>
</body>
</html>
